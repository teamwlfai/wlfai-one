"""
Patient communication and messaging models
"""

from sqlalchemy import (
    Column,
    String,
    Boolean,
    DateTime,
    Text,
    Integer,
    Numeric,
    ForeignKey,
    Enum,
    Index,
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from .base import BaseModel
from .enums import CommunicationType, CommunicationDirection, CommunicationStatus


class Communication(BaseModel):
    """Patient communications (SMS, email, calls, etc.)"""

    __tablename__ = "communications"

    org_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False)
    agent_id = Column(UUID(as_uuid=True), ForeignKey("agents.id"))
    appointment_id = Column(UUID(as_uuid=True), ForeignKey("appointments.id"))
    type = Column(Enum(CommunicationType), nullable=False)
    direction = Column(Enum(CommunicationDirection), nullable=False)
    subject = Column(String(500))
    content = Column(Text, nullable=False)
    status = Column(
        Enum(CommunicationStatus), default=CommunicationStatus.PENDING, nullable=False
    )
    metadata = Column(JSONB, default=dict)
    total_cost_usd = Column(Numeric(10, 4), default=0)
    total_credits_consumed = Column(Integer, default=0)
    service_costs = Column(JSONB, default=dict)
    external_id = Column(
        String(255)
    )  # ID from external service (Twilio, SendGrid, etc.)
    sent_at = Column(DateTime(timezone=True))
    delivered_at = Column(DateTime(timezone=True))
    read_at = Column(DateTime(timezone=True))

    __table_args__ = (
        Index("idx_communication_org", "org_id"),
        Index("idx_communication_patient", "patient_id"),
        Index("idx_communication_agent", "agent_id"),
        Index("idx_communication_appointment", "appointment_id"),
        Index("idx_communication_type", "type"),
        Index("idx_communication_direction", "direction"),
        Index("idx_communication_status", "status"),
        Index("idx_communication_sent", "sent_at"),
        Index("idx_communication_external", "external_id"),
        Index("idx_communication_org_patient", "org_id", "patient_id"),
        Index("idx_communication_patient_type", "patient_id", "type"),
    )

    # Relationships
    organization = relationship("Organization", back_populates="communications")
    patient = relationship("Patient", back_populates="communications")
    agent = relationship("Agent")
    appointment = relationship("Appointment", back_populates="communications")
    service_consumptions = relationship(
        "ServiceConsumption", back_populates="communication"
    )

    @property
    def is_outbound(self):
        """Check if communication is outbound"""
        return self.direction == CommunicationDirection.OUTBOUND

    @property
    def is_inbound(self):
        """Check if communication is inbound"""
        return self.direction == CommunicationDirection.INBOUND

    @property
    def is_sent(self):
        """Check if communication has been sent"""
        return self.status in [
            CommunicationStatus.SENT,
            CommunicationStatus.DELIVERED,
            CommunicationStatus.READ,
        ]

    @property
    def is_delivered(self):
        """Check if communication has been delivered"""
        return self.status in [CommunicationStatus.DELIVERED, CommunicationStatus.READ]

    @property
    def is_read(self):
        """Check if communication has been read"""
        return self.status == CommunicationStatus.READ

    @property
    def is_failed(self):
        """Check if communication failed"""
        return self.status == CommunicationStatus.FAILED

    @property
    def delivery_time_seconds(self):
        """Calculate delivery time in seconds"""
        if self.sent_at and self.delivered_at:
            delta = self.delivered_at - self.sent_at
            return delta.total_seconds()
        return None

    @property
    def read_time_seconds(self):
        """Calculate time to read in seconds"""
        if self.sent_at and self.read_at:
            delta = self.read_at - self.sent_at
            return delta.total_seconds()
        return None

    @property
    def content_preview(self):
        """Get truncated content preview"""
        if len(self.content) <= 100:
            return self.content
        return self.content[:97] + "..."

    @property
    def is_ai_generated(self):
        """Check if communication was generated by AI"""
        return self.agent_id is not None

    def mark_sent(self, external_id=None):
        """Mark communication as sent"""
        self.status = CommunicationStatus.SENT
        self.sent_at = func.now()
        if external_id:
            self.external_id = external_id

    def mark_delivered(self):
        """Mark communication as delivered"""
        if self.status == CommunicationStatus.SENT:
            self.status = CommunicationStatus.DELIVERED
            self.delivered_at = func.now()

    def mark_read(self):
        """Mark communication as read"""
        if self.status in [CommunicationStatus.SENT, CommunicationStatus.DELIVERED]:
            self.status = CommunicationStatus.READ
            self.read_at = func.now()

    def mark_failed(self, error_info=None):
        """Mark communication as failed"""
        self.status = CommunicationStatus.FAILED
        if error_info:
            metadata = self.metadata or {}
            metadata["error"] = error_info
            self.metadata = metadata

    def add_service_cost(
        self, service_type, provider, cost_usd=0, credits=0, details=None
    ):
        """Add service cost breakdown"""
        costs = self.service_costs or {}
        service_key = f"{service_type}_{provider}"

        costs[service_key] = {
            "service_type": service_type,
            "provider": provider,
            "cost_usd": float(cost_usd),
            "credits": credits,
            "details": details or {},
        }

        self.service_costs = costs

        # Update totals
        self.total_cost_usd = sum(s.get("cost_usd", 0) for s in costs.values())
        self.total_credits_consumed = sum(s.get("credits", 0) for s in costs.values())

    def get_delivery_metrics(self):
        """Get delivery performance metrics"""
        return {
            "status": self.status.value,
            "delivery_time_seconds": self.delivery_time_seconds,
            "read_time_seconds": self.read_time_seconds,
            "total_cost": float(self.total_cost_usd or 0),
            "credits_consumed": self.total_credits_consumed,
            "is_ai_generated": self.is_ai_generated,
            "service_count": len(self.service_costs or {}),
        }


class CommunicationTemplate(BaseModel):
    """Templates for automated communications"""

    __tablename__ = "communication_templates"

    org_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False)
    name = Column(String(255), nullable=False)
    type = Column(Enum(CommunicationType), nullable=False)
    subject = Column(String(500))
    content = Column(Text, nullable=False)
    variables = Column(JSONB, default=list)  # List of template variables
    trigger = Column(String(100))  # What triggers this template
    is_active = Column(Boolean, default=True)

    __table_args__ = (
        Index("idx_template_org", "org_id"),
        Index("idx_template_type", "type"),
        Index("idx_template_trigger", "trigger"),
        Index("idx_template_active", "is_active"),
        Index("idx_template_org_type", "org_id", "type"),
    )

    # Relationships
    organization = relationship("Organization")

    @property
    def variable_count(self):
        """Get count of template variables"""
        return len(self.variables or [])

    @property
    def has_variables(self):
        """Check if template has variables"""
        return self.variable_count > 0

    @property
    def content_preview(self):
        """Get truncated content preview"""
        if len(self.content) <= 200:
            return self.content
        return self.content[:197] + "..."

    def render(self, variables_dict):
        """Render template with provided variables"""
        rendered_subject = self.subject
        rendered_content = self.content

        if variables_dict and self.variables:
            for var_name in self.variables:
                if var_name in variables_dict:
                    placeholder = f"{{{{{var_name}}}}}"
                    value = str(variables_dict[var_name])

                    if rendered_subject:
                        rendered_subject = rendered_subject.replace(placeholder, value)
                    rendered_content = rendered_content.replace(placeholder, value)

        return {"subject": rendered_subject, "content": rendered_content}

    def validate_variables(self, variables_dict):
        """Validate that all required variables are provided"""
        if not self.variables:
            return {"valid": True, "missing": []}

        missing_vars = []
        for var_name in self.variables:
            if var_name not in variables_dict:
                missing_vars.append(var_name)

        return {"valid": len(missing_vars) == 0, "missing": missing_vars}

    def extract_variables_from_content(self):
        """Extract variable placeholders from content"""
        import re

        # Find all {{variable}} patterns
        pattern = r"\{\{([^}]+)\}\}"
        variables = set()

        # Extract from subject
        if self.subject:
            variables.update(re.findall(pattern, self.subject))

        # Extract from content
        variables.update(re.findall(pattern, self.content))

        # Update the variables list
        self.variables = list(variables)
        return list(variables)

    def create_communication(
        self, patient_id, variables_dict=None, agent_id=None, appointment_id=None
    ):
        """Create a communication from this template"""
        rendered = self.render(variables_dict or {})

        return {
            "org_id": self.org_id,
            "patient_id": patient_id,
            "agent_id": agent_id,
            "appointment_id": appointment_id,
            "type": self.type,
            "direction": CommunicationDirection.OUTBOUND,
            "subject": rendered["subject"],
            "content": rendered["content"],
            "metadata": {
                "template_id": str(self.id),
                "template_name": self.name,
                "variables_used": variables_dict or {},
            },
        }

    @classmethod
    def get_by_trigger(cls, session, org_id, trigger_type):
        """Get active templates by trigger type"""
        return (
            session.query(cls)
            .filter(
                cls.org_id == org_id, cls.trigger == trigger_type, cls.is_active == True
            )
            .all()
        )

    def get_usage_stats(self, session):
        """Get usage statistics for this template"""
        from sqlalchemy import func as sql_func

        # Count communications created from this template
        communication_count = (
            session.query(sql_func.count(Communication.id))
            .filter(Communication.metadata.contains({"template_id": str(self.id)}))
            .scalar()
        )

        # Calculate success rate
        successful_count = (
            session.query(sql_func.count(Communication.id))
            .filter(
                Communication.metadata.contains({"template_id": str(self.id)}),
                Communication.status.in_(
                    [
                        CommunicationStatus.SENT,
                        CommunicationStatus.DELIVERED,
                        CommunicationStatus.READ,
                    ]
                ),
            )
            .scalar()
        )

        success_rate = (
            (successful_count / communication_count * 100)
            if communication_count > 0
            else 0
        )

        return {
            "total_communications": communication_count,
            "successful_communications": successful_count,
            "success_rate": success_rate,
            "template_variables": self.variable_count,
        }
